<!Doctype html>
<html lang="de">
  <head>
    <!--character encoding, viewport & title-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schwabauer &ndash; Simulator</title>

    <!--font-->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anonymous+Pro:ital,wght@0,400;0,700;1,400;1,700&family=Cascadia+Code:ital,wght@0,200..700;1,200..700&family=Cascadia+Mono:ital,wght@0,200..700;1,200..700&family=Caveat:wght@400..700&family=Crimson+Text:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,100..900;1,100..900&family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&display=swap" rel="stylesheet">

    <!--css-->
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/header.css">
    <link rel="stylesheet" href="css/footer.css">
    <link rel="stylesheet" href="css/content.css">

    <link rel="stylesheet" href="css/simulator.css">

    <!--JavaScript-->
    <script src="js/home.js"></script>
  </head>

  <body>
    <header class="header">
      <nav class="header__nav">
        <ul class="header__list">
          <li class="header__item header__item--brand">
            <h5>
              <a href="index.html">
                <span class="brand-full">Niklas Schwabauer</span>
                <span class="brand-short">Schwabauer</span>
              </a>
            </h5>
          </li>
          <li class="header__item header__item--menu">
            <ul class="header__submenu">
              <li class="header__submenu-item"><a href="personal.html">Profil</a></li>
              <li class="header__submenu-item"><a href="projects.html">Projekte</a></li>
              <li class="header__submenu-item"><a href="contact.html">Kontakt</a></li>
            </ul>
          </li>
        </ul>
      </nav>
    </header>

    <main id="personal" class="main" role="main">
      <section class="hero">
        <div class="hero__content">
          <div class="hero__headline"><p>Racing Simulator</p></div>
          <div class="hero__text">
            <div class="hero__text-line">
              <p>Kein fertiges Produkt, sondern ein Experiment:</p>
            </div>
            <div class="hero__text-line">
              <p>Ein Racing-Simulator, der Technik erlebbar macht</p>
            </div>
            <div class="hero__text-line hero__text-line--italic">
              <p>&ndash; von CAD bis Code!</p>
            </div>
          </div>
          <div class="hero__table">
            <div class="hero__table-headline"><p>Inhaltsverzeichnis</p></div>
            <ul class="hero__table-content">
              <li class="hero__table-item">
                <span class="hero__table-number">1.</span>
                <a href="simulator.html#chapter-1" class="hero__table-link">Einleitung</a>
              </li>
              <li class="hero__table-item">
                <span class="hero__table-number">2.</span>
                <a href="simulator.html#chapter-2" class="hero__table-link">Überblick über den Aufbau</a>
              </li>
              <li class="hero__table-item">
                <span class="hero__table-number">3.</span>
                <a href="simulator.html#chapter-3" class="hero__table-link">Mechanik im Detail</a>
              </li>
              <li class="hero__table-item">
                <span class="hero__table-number">4.</span>
                <a href="simulator.html#chapter-4" class="hero__table-link">Die optischen Encoder</a>
              </li>
              <li class="hero__table-item">
                <span class="hero__table-number">5.</span>
                <a href="simulator.html#chapter-5" class="hero__table-link">Signalübertragung</a>
              </li>
              <li class="hero__table-item">
                <span class="hero__table-number">6.</span>
                <a href="simulator.html#chapter-6" class="hero__table-link">Reflexion</a>
              </li>
              <li class="hero__table-item">
                <span class="hero__table-number">7.</span>
                <a href="simulator.html#chapter-7" class="hero__table-link">Unterstützung durch KI</a>
              </li>
              <li class="hero__table-item">
                <span class="hero__table-number">8.</span>
                <a href="simulator.html#chapter-8" class="hero__table-link">Downloads</a>
              </li>
            </ul>
          </div>
        </div>
        <div class="hero__image">
          <img src="img/wheel_hero.png" alt="me" class="hero__img hero__wheel-hero">
        </div>
      </section>

      <section class="chapter" id="chapter-1">
        <div class="chapter__headline"><p>1. Mein eigener Rennsimulator</p></div>
        <div class="chapter__subhead">
          <p>Technik begeistert &ndash; insbesondere dann, wenn sie Präzision, Ästhetik und Ingenieurskunst miteinander vereint. 
            Fahrzeuge renommierter deutscher Hersteller wie Porsche oder BMW sind weit mehr als bloße Fortbewegungsmittel: 
            Sie sind Beispiele technischer Exzellenz, wirtschaftlicher Bedeutung und funktionaler Gestaltung. Als technikaffiner Autoliebhaber fasziniert mich dieser Anspruch &ndash; auch im Kontext des Motorsports, 
            wo Disziplinen wie DTM, WEC oder die Formel 1 für Innovation, Leistung und Effizienz stehen.</p>
          <p>Über diesen Weg entstand mein Interesse am Simracing. Professionelle Anbieter wie Simucube, Heusinkveld oder GSI haben den Bereich längst aus der Nische geführt 
            &ndash; ihre Produkte stehen für Präzision und Qualität, sind aber für den Rennsport typisch auch preislich in diesem Segment angeordnet. Die Idee war daher klar: Ein eigenes System entwickeln. 
            Nicht als Nachbau kommerzieller Lösungen, sondern als technisches Experiment, in dem das Lernen und Verstehen im Vordergrund steht.</p>
          <p>So entstand mein selbst entwickelter Rennsimulator &ndash; ein interdisziplinäres Projekt, das Mechanik, Elektronik und Software vereint. 
            Grundlage war der Wunsch, praxisorientiert zu arbeiten: Statt Theorie dominierte hier die Anwendung &ndash; jedes Bauteil wurde konstruiert, gedruckt, getestet und optimiert. 
            Mit Fusion 360 entstand das mechanische Design, der 3D-Druck wurde über Bambu Studio umgesetzt. Ich entwickelte eigene Federsysteme, 
            arbeitete mit Fotowiderständen und realisierte die Signalverarbeitung mithilfe eines ESP8266-Mikrocontrollers und eines ADS1115-AD-Wandlers. 
            Ziel war es, Sensordaten möglichst präzise zu erfassen, zu analysieren und digital in Eingaben umzusetzen.</p>
          <p>Mein technisches Vorwissen entstand schrittweise: von LEGO über fischertechnik bis hin zu Arduino-Projekten und ersten CAD-Erfahrungen mit FreeCAD. 
            Doch vieles war neu &ndash; insbesondere die Kommunikation via Bluetooth, 
            die Echtzeit-Auswertung analoger Signale und die Integration über Tools wie vJoy zur Weitergabe von Steuerbefehlen an Spiele wie Forza Horizon.</p>
          <p>Begleitet wurde das Projekt durch den Einsatz von ChatGPT &ndash; nicht als Ersatz für eigenes Denken, sondern als effektives Werkzeug zur Problemlösung: 
            bei Fehlersuche, Codeinterpretation und der konzeptionellen Planung technischer Teilbereiche. Diese Form der digitalen Unterstützung ermöglichte eine effiziente, lösungsorientierte Herangehensweise 
            &ndash; vergleichbar mit einer interaktiven technischen Rechercheplattform.</p>
          <p>Das Ergebnis ist kein marktfertiges Produkt, sondern ein durchdachtes, technisch tiefgehendes System. Es soll nicht zum Nachbau anregen, sondern zum Verstehen. Ziel ist es, 
            komplexe Abläufe und Fachbegriffe so aufzubereiten, dass sie nachvollziehbar und greifbar werden 
            &ndash; auch für jene, die sich bislang nicht intensiv mit Mikrocontrollern, Sensorik oder CAD befasst haben.</p>
        </div>
      </section>

      <section class="image">
        <img src="img/wheel_classic.png" alt="wheelbase-CAD" class="img img__wheel-classic">
      </section>

      <section class="chapter" id="chapter-2">
        <div class="chapter__headline"><p>2. Überblick über den Aufbau</p></div>
        <div class="chapter__subhead">
          <p>Der selbstentwickelte Simulator folgt einem einfachen, aber technisch durchdachten Aufbau: Eine direkt gelagerte Lenkeinheit, 
            ein selbstgedruckter Drehfederelement-Satz, ein optisch arbeitender Encoder sowie eine Bluetooth-Anbindung an den PC bilden das funktionale Grundgerüst. 
            Der Schwerpunkt des Projekts lag auf einem möglichst modularen, 
            vollständig selbst herstellbaren Aufbau &ndash; insbesondere im Bereich der Mechanik und Sensorik.</p>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>2.1 Grundkonzept des Lenkmechanismus</p></div>
          <div class="chapter__container-text">
            <p>Zentrales Element ist die rotierende Lenkwelle, die über zwei gegenüberliegend gespannte, spiralförmige PLA-Torsionsfedern gegen ihre Drehrichtung arbeitet. 
              Die Kraftübertragung erfolgt direkt, ohne zwischengeschaltete Getriebestufen zwischen Hand und Feder &ndash; ein Ansatz, der für lineare Rückstellmomente und eine kompakte Bauform sorgt. 
              Die Verbindung zur Sensorik erfolgt über eine per Zahnrad übersetzte Nebenwelle, auf der die Encoderscheiben montiert sind.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>2.2 Sensorik und Signalauswertung</p></div>
          <div class="chapter__container-text">
            <p>Zur Erfassung der Rotationsbewegung kommt ein selbstentwickeltes optisches Encodersystem zum Einsatz. 
              Zwei leicht versetzt angeordnete, aus PLA gefertigte Codierscheiben mit abwechselnd lichtdurchlässigen und lichtundurchlässigen Segmenten erzeugen bei Drehung ein nahezu sinusförmiges Signal. 
              Die Lichtstärke wird analog erfasst und zur Bestimmung der Drehrichtung sowie der aktuellen Stellung genutzt. Die Genauigkeit des Systems hängt dabei stark von der Rotationsgeschwindigkeit und der Auslesefrequenz ab 
              &ndash; ein Aspekt, der im weiteren Verlauf noch vertieft wird.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>2.3 Kommunikation mit dem PC</p></div>
          <div class="chapter__container-text">
            <p>Die Verarbeitung der analogen Signale erfolgt auf einem Mikrocontroller (ESP8266), der sie per Bluetooth an den PC überträgt. 
              Dort werden die Werte mit Hilfe von vJoy in virtuelle Gamepad-Signale umgesetzt. Die Verbindung über USB ist parallel für die Programmierung und Konfiguration nutzbar. 
              Die Integration in Spiele ist grundsätzlich möglich, 
              wenngleich bestimmte Grenzen bestehen &ndash; etwa in Bezug auf Reaktionsgeschwindigkeit und Präzision.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>2.4 Technische Herausforderungen und Grenzen</p></div>
          <div class="chapter__container-text">
            <p>Schon während des Aufbaus wurde deutlich, dass das System seine Grenzen nicht im mechanischen Aufbau, sondern in der Datenverarbeitung erreicht: 
              Die Kombination aus selbstgebautem Encoder, analoger Signalverarbeitung und limitierter Abtastrate des Mikrocontrollers führt zu Genauigkeitsverlusten 
              &ndash; insbesondere bei schnellen Bewegungen. Diese Einschränkungen schränken den praktischen Einsatz als vollwertiger Simulator ein, 
              stellten aber gleichzeitig den gewünschten technischen Reiz dar.</p>
            <p>Trotz (oder gerade wegen) dieser Herausforderungen wurde das Projekt als erfolgreich abgeschlossen gewertet. 
              Der Fokus lag nicht auf industrieller Reproduzierbarkeit, sondern auf einem vollständigen, funktionalen Eigenentwurf mit Lerncharakter 
              &ndash; inklusive mechanischer Konstruktion, Sensorikentwicklung, Signalverarbeitung und PC-Anbindung.</p>
          </div>
        </div>
      </section>

      <section class="image">
        <img src="img/wheel_sketch.png" alt="wheel_sketch" class="img img__wheel-sketch">
      </section>

      <section class="chapter" id="chapter-3">
        <div class="chapter__headline"><p>3. Die Mechanik im Detail</p></div>
        <div class="chapter__subhead">
          <p>Wie lassen sich Lenkung, Kraftübertragung und Positionsmessung mechanisch lösen &ndash; ohne auf teure Fertigteile zurückzugreifen? In diesem Kapitel geht es um genau diese Frage. 
            Alle mechanischen Komponenten des Projekts wurden entweder selbst entwickelt oder mit dem 3D-Drucker hergestellt. Im Zentrum steht dabei die Lenkwelle als tragendes Bauteil, 
            auf das alle weiteren Funktionen aufbauen: Kraftübertragung, Drehmomentmessung, Lagerung und Signalübertragung.</p>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>3.1 Die Lenkwelle: Mehr als nur ein Träger</p></div>
          <div class="chapter__container-text">
            <p>Zentrales Element ist die rotierende Lenkwelle, die über zwei gegenüberliegend gespannte, spiralförmige PLA-Torsionsfedern gegen ihre Drehrichtung arbeitet. 
              Die Kraftübertragung erfolgt direkt, ohne zwischengeschaltete Getriebestufen zwischen Hand und Feder &ndash; ein Ansatz, der für lineare Rückstellmomente und eine kompakte Bauform sorgt. 
              Die Verbindung zur Sensorik erfolgt über eine per Zahnrad übersetzte Nebenwelle, auf der die Encoderscheiben montiert sind.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>3.2 Zahnräder: Kraftübertragung mit Übersetzung</p></div>
          <div class="chapter__container-text">
            <p>Die eigentliche Drehbewegung wird über zwei 3D-gedruckte Zahnräder übertragen: 
              Ein kleineres Zahnrad (11 Zähne) ist direkt auf der Lenkwelle montiert, ein größeres (33 Zähne) greift in dieses ein. Damit ergibt sich eine Übersetzung von etwa 3 : 1 
              &ndash; langsame Lenkbewegungen erzeugen so eine verstärkte Reaktion im Sensorbereich, was die Auflösung der Auswertung verbessert.</p>
            <p>Beide Zahnräder greifen sauber ineinander. Zwar gibt es durch die Fertigungstoleranzen im 3D-Druck ein geringes Spiel, doch dieses ist in der Praxis vernachlässigbar 
              &ndash; insbesondere, da andere Teile des Systems wie die Torsionsfederlagerung oder die Schleifkontakte ohnehin deutlich reibungsintensiver arbeiten. Die Zahnräder sind zwar hörbar, aber nicht störend 
              &ndash; lauter ist die Reibung zwischen Encoderscheiben und Sensoraufnahmen. Diese Reibung ist dabei nicht nur ein Nebeneffekt, sondern sogar gewollt: Um die Sensoren zuverlässig gegen Fremdlicht zu schützen, 
              muss der Lichtspalt möglichst eng geführt werden &ndash; was unweigerlich zu leichtem Schleifkontakt führt.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>3.3 Stromübertragung über Schleifkontakte</p></div>
          <div class="chapter__container-text">
            <p>Um Tasten auf dem Lenkrad abfragen zu können, müssen Signale von der rotierenden Lenkwelle zum feststehenden Mikrocontroller übertragen werden. Die Lösung: Ein Schleifkontakt 
              &ndash; umgesetzt mit klassischen Mitteln, aber untypischer Ausführung.</p>
            <p>Zunächst wurden Kupferdrähte abisoliert und spiralförmig um die Lenkwelle gewickelt. Dadurch entstehen geschlossene Kontaktbereiche, die ringförmig auf der Welle aufliegen. 
              Um die Leitfähigkeit zu erhöhen, wurden diese Ringe zusätzlich verzinnt und anschließend mit dünneren Kabeln verlötet, die zur Elektronik führen. 
              Die Kontaktierung selbst erfolgt über federnd gelagerte Abnehmer, die von unten im 45°-Winkel gegen die rotierende Welle drücken. 
              Die Federn sind so angeordnet, dass sie tangential zur Welle wirken und gleichzeitig stabil geführt werden 
              &ndash; ganz ohne äußere Führungsschiene. Durch die enge Platzierung der Abnehmer ergibt sich ein fast spielfreier Aufbau.</p>
            <p>Das ganze Modul ist an einer zusätzlichen (deutlich dünneren) PLA-Stange montiert, die parallel zur Lenkwelle verläuft und alle Abnehmer stabil hält. Insgesamt sind zwei Gruppen verbaut: Eine mit zwei, eine mit drei Abnehmern 
              &ndash; getrennt durch eine 4 mm starke Distanzstruktur. Die Kontaktqualität war im Betrieb stabil genug, da für die Schalterabfrage keine dauerhafte Signalübertragung nötig ist. 
              Kurzzeitige Kontaktverluste werden durch die Trägheit des Tastendrucks überbrückt.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>3.4 Das Kugellager: Leichtlauf mit Airsoft-Kugeln</p></div>
          <div class="chapter__container-text">
            <p>Die Lagerung der Lenkwelle erfolgt über ein eigens entwickeltes 3D-gedrucktes Kugellager mit Airsoft-Kugeln als Wälzkörper. 
              In zwei Kammern wurden je 12 Kugeln eingesetzt, also insgesamt 24 pro Lager. Die Kugeln laufen trocken &ndash; also ohne Schmierung 
              &ndash; was zwar zu einer gewissen Geräuschentwicklung führt, aber in der Praxis kaum ins Gewicht fällt. Entscheidend ist: Der Lauf ist extrem leichtgängig. Die Welle dreht sich mühelos und läuft nach dem Andrehen deutlich nach 
              &ndash; ganz wie bei einem echten Kugellager. Axiale und radiale Kräfte werden durch die doppelte Lagerung zuverlässig abgefangen. 
              Brüche oder Materialversagen wurden während des Tests nicht beobachtet.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>3.5 Die Torsionsfedern: Gedruckte Elastizität</p></div>
          <div class="chapter__container-text">
            <p>Die Rückstellkraft des Lenkrads wird durch spiralförmige PLA-Torsionsfedern erzeugt. Diese wurden parametrisch in Fusion 360 modelliert und umschließen die Lenkwelle formschlüssig. 
              In ihrer Mitte besitzen die Federn eine runde Aufnahme mit zentralem Loch und Aussparungen, die exakt zur Wellengeometrie passen &ndash; so wird das Drehmoment direkt übertragen. 
              Der äußere Bereich ist ebenfalls mit einer gezielten Geometrie versehen, um die Feder am Gehäuse fixieren zu können.</p>
            <p>Eine genaue Kraftmessung wurde nicht durchgeführt. Subjektiv ist die Rückstellkraft deutlich spürbar, aber nicht übermäßig 
              &ndash; vergleichbar mit einem leichten Fahrzeuglenkrad ohne Servounterstützung. Da die Federn im eingebauten Zustand gerade belastet sind, lassen sich Unterschiede in der Steifigkeit schwer nachprüfen. 
              Wahrscheinlich bestehen leichte Varianzen durch Drucktemperatur, Wandstärke oder Restspannung im Material. 
              Typische Kraftverläufe solcher Torsionsfedern folgen einer nahezu linearen Kennlinie im elastischen Bereich, idealisiert durch die Beziehung:</p>
            <p>M = k ⋅ θ</p>
            <p>wobei M das Drehmoment, θ der Verdrehwinkel und k die Torsionsfederkonstante ist. Die Form der Feder bestimmt maßgeblich die Steifigkeit.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>3.6 Montage und Wartung</p></div>
          <div class="chapter__container-text">
            <p>Trotz des komplexen Aufbaus zeigten sich im Betrieb nur wenige Probleme. Lediglich das Gehäuse lockerte sich gelegentlich 
              &ndash; ein Problem, das sich durch Einkleben dauerhaft beheben ließe, aber derzeit aus Wartungsgründen bewusst offen bleibt. Die restliche Mechanik ist überraschend robust: 
              Weder mussten Bauteile ersetzt werden, noch traten relevante mechanische Schwächen auf. Ein Indiz dafür, dass die Planung sorgfältig war 
              &ndash; und dass 3D-Druck in Kombination mit handwerklicher Nacharbeit durchaus eine ernstzunehmende Option für funktionale Mechanik darstellt.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>3.7 Einordnung: Was war spannend &ndash; was aufwendig?</p></div>
          <div class="chapter__container-text">
            <p>Besonders spannend war das Experimentieren mit den Encoderscheiben: Zahlreiche Varianten wurden gedruckt und getestet, um eine möglichst präzise und dennoch robuste Auswertung zu ermöglichen. 
              Hier zeigte sich unmittelbar der Zusammenhang zwischen Geometrie, Drehgeschwindigkeit und Auslesegenauigkeit 
              &ndash; und auch die Grenze des technisch Machbaren. Wie bei der Quantenmechanik gibt es gewissermaßen eine Art Messunschärfe: Die exakte Position, 
              Geschwindigkeit und Richtung können nicht beliebig genau gleichzeitig bestimmt werden &ndash; zumindest nicht bei dieser Hardware.</p>
            <p>Aufwendig war vor allem die Entwicklung der Schleifkontakte. Erste Versuche mit Alufolie scheiterten erwartungsgemäß an Haltbarkeit und Leitfähigkeit. 
              Die Lösung mit verzinnten Kupferdrähten sieht nicht nur sauber aus, sondern funktioniert auch &ndash; war aber in der Umsetzung langwierig. 
              Jeder Ring, jeder Kontakt musste exakt positioniert, verlötet und stabilisiert werden. Am Ende aber hat sich der Aufwand gelohnt: Die Mechanik bildet das Rückgrat des Projekts 
              &ndash; und macht auch auf den zweiten Blick klar, wie viel Technik in einem simplen Lenkrad stecken kann.</p>
          </div>
        </div>
      </section>

      <section class="image">
        <img src="img/parts.png" alt="3D-parts" class="img img__parts">
      </section>

      <section class="chapter" id="chapter-4">
        <div class="chapter__headline"><p>4. Der optische Encoder: Licht, Schatten und Richtung</p></div>
        <div class="chapter__subhead">
          <p>Die präzise Bestimmung der Lenkradposition ist das zentrale Element jedes Simulators. In meinem Fall fiel die Wahl nicht auf einen handelsüblichen Encoder, sondern 
            &ndash; ganz im Sinne des Projekts &ndash; auf einen selbstgebauten, rein optisch funktionierenden Drehgeber. 
            Ein bewusster Schritt, der nicht nur technische Herausforderungen mit sich brachte, sondern auch eine Menge an Lerngelegenheiten bot.</p>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>4.1 Die Encoderscheiben &ndash; Lichttore aus PLA</p></div>
          <div class="chapter__container-text">
            <p>Kernstück des Systems sind zwei identische, selbst designte Encoderscheiben. Diese bestehen aus schwarzem PLA und setzen sich jeweils aus einem Innen- und Außenring zusammen. 
              Der Innenring dient der Befestigung an der drehenden Welle, während der Außenring die entscheidenden Aussparungen trägt.</p>
            <p>Jede Scheibe besitzt insgesamt 18 gleich große Segmente, von denen 9 lichtdurchlässig (mit Aussparung) und 9 lichtundurchlässig sind. 
              Die lichtdurchlässigen Elemente haben eine Breite von 5 mm und sind mittig im Außenring eingelassen &ndash; sie wirken wie leicht gebogene Rechtecke, was durch die Kreisform bedingt ist. 
              Der Außendurchmesser der Scheibe beträgt 105 mm, 
              der Innendurchmesser des Außenrings liegt bei 85 mm. Die Dicke der gesamten Scheibe beträgt 4 mm.</p>
            <p>Die genaue Positionierung und Symmetrie der Segmente war das Ergebnis mehrerer Iterationen. Anfangs experimentierte ich mit verschieden großen und geformten Ausschnitten 
              (u.a. kreisförmig oder schmaler), doch am Ende setzte sich ein gleichmäßig segmentiertes Design durch. Die damit erreichte Auflösung entsprach rechnerisch 20 Grad pro Segment 
              (360° ÷ 18), was zwar unter meiner ursprünglich angestrebten Zielgröße von 5 Grad blieb, 
              aber aufgrund der vielen praktischen Einflüsse (Drehgeschwindigkeit, Latenzen, Toleranzen) realistischer umsetzbar war.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>4.2 Das Test-Rig &ndash; Prototyp für Lichtspiele</p></div>
          <div class="chapter__container-text">
            <p>Noch vor dem eigentlichen Simulator entstand ein kleines Test-Rig: eine einfache Kurbelkonstruktion mit montierter Scheibe und einem ersten Sensorhalter. 
              Hier konnte ich die Grundidee der optischen Abtastung überprüfen &ndash; per Hand angetrieben, manuell ausgerichtet und Schritt für Schritt validiert. 
              Dieses Mini-Projekt diente als wichtiger Machbarkeitsnachweis, bevor die Idee später in das eigentliche Lenksystem überführt wurde.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>4.3 Sensorik &ndash; Licht und Widerstand</p></div>
          <div class="chapter__container-text">
            <p>Jede Encoderscheibe wird mit einem Sensorpaar aus LED und Fotowiderstand abgetastet. Die LED sitzt auf der einen Seite der Scheibe, der Fotowiderstand exakt gegenüber. 
              Bei Drehung der Scheibe fällt im Rhythmus der Aussparungen entweder Licht auf den Sensor oder wird blockiert 
              &ndash; daraus ergibt sich ein analoger Lichtwert, der später digital interpretiert wird.</p>
            <p>Diese Sensorpaare sind als einzelne Module aufgebaut: LED und Sensor sind jeweils fest montiert, und das Modul wird exakt so ins Gehäuse eingesetzt, dass die Encoderscheibe mittig durchläuft. 
              Der Abstand zwischen LED, Scheibe und Sensor wurde bewusst minimal gewählt, um Streulicht oder LED-Helligkeitsschwankungen zu minimieren.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>4.4 Zwei Scheiben für die Drehrichtung</p></div>
          <div class="chapter__container-text">
            <p>Ein besonders cleverer Aspekt des Designs: Zur Erkennung der Drehrichtung werden zwei Encoderscheiben verwendet 
              &ndash; beide auf derselben Welle montiert, aber zueinander um 90° phasenversetzt (π/2). Damit ergibt sich bei Drehung ein zeitlicher Versatz zwischen den beiden Sensorsignalen, 
              aus dem sich die Richtung eindeutig ableiten lässt &ndash; ganz im Prinzip eines Quadraturgebers.</p>
            <p>Obwohl man alternativ auch zwei Sensoren an einer Scheibe hätte platzieren können, 
              war die Entscheidung für zwei separate Scheiben im Nachhinein sogar vorteilhaft: So konnten identische Bauteile doppelt genutzt werden 
              &ndash; ideal für ein Prototypensystem, in dem Wiederverwendbarkeit und Klarheit im Vordergrund standen.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>4.5 Auswertung auf dem ESP8266</p></div>
          <div class="chapter__container-text">
            <p>Die Signale beider Fotowiderstände werden analog über den ADS1115 ausgelesen, einem hochauflösenden A/D-Wandler, der via I²C mit dem ESP8266 kommuniziert. 
              In der Software wurden die kontinuierlichen Helligkeitswerte anschließend durch festgelegte Schwellwerte 
              (Stichwort: Thresholding) in digitale Zustände („Licht“ / „kein Licht“) überführt.</p>
            <p>Die Herausforderung: Bei schnellen Drehbewegungen wurde der Schwellwert teilweise nicht rechtzeitig erreicht, 
              was zu Fehlinterpretationen oder „vertauschten“ Signalzuständen führte. Besonders problematisch war dies, wenn die Werte beider 
              Sensoren sich annäherten oder nahezu gleichzeitig die Schwelle über- bzw. unterschritten &ndash; die Richtungserkennung versagte dann.</p>
            <p>Ein möglicher Grund: optische Dämpfungseffekte. Ähnlich wie bei einem PWM-Signal könnte bei schnellen Bewegungen das Licht nicht 
              konstant genug durchdringen oder vollständig blockiert werden, was zu verrauschten, mittleren Signalwerten führte.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>4.6 Erkennung & Genauigkeit</p></div>
          <div class="chapter__container-text">
            <p>Die Drehrichtung ließ sich bei korrekt justierten Schwellenwerten und moderater Drehgeschwindigkeit zuverlässig erkennen. 
              Eine feinere Justierung der Grenzwerte hätte theoretisch die Auflösung erhöht, gleichzeitig aber die Empfindlichkeit gegenüber Geschwindigkeit verstärkt. 
              Hier zeigte sich das grundlegende Dilemma:</p>
            <p>„Maximale Genauigkeit bedeutet minimale Geschwindigkeit &ndash; maximale Geschwindigkeit bedeutet minimale Genauigkeit.“</p>
            <p>Trotzdem war das System in der Praxis nutzbar 
              &ndash; solange sich die Bewegung im realistischen Rahmen eines Rennspiels bewegte, funktionierte die Erkennung überzeugend.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>4.7 Softwareseitige Umsetzung und vJoy</p></div>
          <div class="chapter__container-text">
            <p>Die Auswertung erfolgte über ein Python-Skript, das die eingehenden Werte interpretierte. Die erste Encoderscheibe lieferte den Abtastimpuls: 
              Bei jedem Wechsel von Hell zu Dunkel (bzw. umgekehrt) wurde die interne Zählposition um eins erhöht oder verringert &ndash; abhängig von der Zustandsänderung der zweiten, versetzten Scheibe. 
              Letztere diente rein der Richtungserkennung, trug aber indirekt ebenfalls zur Positionierung bei.</p>
            <p>Die berechnete Position wurde anschließend per vJoy-Schnittstelle an den PC übergeben und dort als virtuelles Gamepad-Signal interpretiert. 
              In vielen Spielen war dies problemlos nutzbar &ndash; lediglich in Spielen wie Forza Horizon wäre zusätzlich eine umfassende Treiberumgebung nötig gewesen, 
              die ich bewusst nicht installieren wollte aufgrund von potenziellen Anticheat-Problemen in anderen Spielen.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>4.8 Fazit &ndash; Funktion vs. Erfahrung</p></div>
          <div class="chapter__container-text">
            <p>
              Der selbstgebaute optische Encoder funktionierte überraschend zuverlässig &ndash; zumindest im Rahmen der gewählten technischen Mittel. 
              Kleinste Bewegungen wurden nicht immer erkannt, die Genauigkeit variierte mit der Drehgeschwindigkeit, 
              und natürlich war das System nicht mit einem industriellen Drehgeber vergleichbar.</p>
            <p>
              Aber: Es war mein Design, mein Experiment, mein Fortschritt. 
              <br>
              Ein kommerzieller Encoder hätte zweifellos besser funktioniert. Doch Ziel dieses Projekts war nicht Effizienz &ndash; sondern Verständnis. 
              Und genau das wurde mit jedem Ausschnitt, jedem Sensorwert und jedem Aha-Moment tiefer.
            </p>
          </div>
        </div>
      </section>

      <section class="image">
        <img src="img/wheel_all.png" alt="wheelbase-CAD" class="img img__wheel-all">
      </section>

      <section class="chapter" id="chapter-5">
        <div class="chapter__headline"><p>5. Signalübertragung per Bluetooth</p></div>
        <div class="chapter__subhead">
          <p>Wer glaubt, dass die größte Herausforderung eines DIY-Simulators im mechanischen Bau liegt, wird schnell eines Besseren belehrt 
            &ndash; denn auch das Thema Datenübertragung verdient Aufmerksamkeit. Wie kommen die Lenksignale vom selbstgebauten Eingabegerät eigentlich ins Spiel? 
            Die Antwort: erstaunlich unspektakulär, aber absolut funktional &ndash; über Bluetooth. Ein simples HC-05-Modul übernimmt die Rolle des stillen Vermittlers zwischen Mikrocontroller und PC 
            &ndash; und leistet dabei mehr, als man auf den ersten Blick vermuten würde.</p>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>5.1 Warum eigentlich Bluetooth?</p></div>
          <div class="chapter__container-text">
            <p>Die Entscheidung, Bluetooth als Übertragungsweg zu nutzen, war keine reine Frage der Technik, sondern vielmehr das Ergebnis einer pragmatischen Abwägung. 
              USB schied frühzeitig aus &ndash; nicht etwa, weil der verwendete Mikrocontroller, ein ESP8266 (Wemos D1 mini), 
              keinen USB-Anschluss besäße, sondern weil dieser nur zur Stromversorgung genutzt werden kann. Als Eingabegerät kann sich der ESP nicht ohne weiteres gegenüber dem PC ausgeben. 
              Auch Wi-Fi wurde bewusst ausgeschlossen: Zwar hätte es eine deutlich höhere Übertragungsgeschwindigkeit ermöglicht, doch im Kontext von grafikintensiven Spielen war eine stabile Internetverbindung wichtiger als interne Datenraten 
              &ndash; und genau diese hätte eine WLAN-Übertragung stören können.</p>
            <p>Entscheidend war letztlich aber auch der Blick in die Bastelkiste: Ein HC-05-Bluetooth-Modul aus einem alten Arduino-Set lag schon länger ungenutzt herum 
              &ndash; und bot sich damit als ideale Lösung an. Einfach zu verschalten, zuverlässig und für serielle Daten wie geschaffen. 
              Zwar ist Bluetooth in puncto Geschwindigkeit nicht konkurrenzfähig zu modernen Controllern wie dem Xbox Wireless, doch für diesen Anwendungsfall reichte es vollkommen aus. 
              Die Verbindung ist stabil, das Pairing funktioniert nach kurzer Wartezeit, und sobald der Kanal steht, wird jede Lenkbewegung zuverlässig übertragen. 
              Kurz gesagt: Bluetooth war nicht nur die einfache, sondern auch die sinnvolle Lösung.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>5.2 Die Hardware: Einfach, aber effektiv</p></div>
          <div class="chapter__container-text">
            <p>Der HC-05 wurde direkt an den ESP8266 angeschlossen &ndash; ohne zusätzliche Spannungsquelle, direkt über RX/TX. Trotz vieler Internetbeiträge, 
              die auf potenzielle Probleme bei der Stromversorgung hinweisen, lief alles stabil. Der verwendete D1 Mini scheint ausreichend Leistung bereitzustellen 
              &ndash; oder anders gesagt: Glück gehabt, aber mit System.</p>
            <p>Die Verkabelung war unkompliziert &ndash; einzig die klassische RX-TX-Verwirrung kostete kurzzeitig Nerven, war aber schnell behoben. Auch die Flash-Problematik 
              (während RX und TX belegt sind) wurde elegant gelöst: Zwei kleine Taster auf der Platine unterbrechen manuell die Verbindung zum HC-05, wenn ein neues Programm aufgespielt werden muss. 
              Einfach, clever, zuverlässig.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>5.3 Die Software auf dem ESP: AD-Wandlung, Schmitt-Trigger, Encoder-Logik</p></div>
          <div class="chapter__container-text">
            <p>Auf dem ESP8266 läuft ein Arduino-Sketch, der mit dem I²C-basierten ADS1115-Wandler vier analoge Eingänge ausliest. 
              Für das Lenkrad relevant sind hier insbesondere zwei Kanäle: Die A- und B-Signale eines mechanischen Quadratur-Encoders. 
              Diese werden digitalisiert und dann mithilfe eines softwareseitigen Schmitt-Triggers geglättet.</p>
            <p>Der Trigger vermeidet zufällige Schaltflanken durch Wackler oder Störungen. Erst wenn eine Spannung einen definierten Schwellenwert über- oder unterschreitet, 
              wird ein Zustandswechsel angenommen &ndash; konkret hier mit folgenden Grenzen:</p>
            <p>
              #define thresholdHighA 15000
              <br>
              #define thresholdLowA  5000
            </p>
            <p>Die Encoder-Auswertung selbst erfolgt durch Vergleich der aktuellen und vorherigen Zustände der A- und B-Spuren. Je nachdem, 
              in welcher Reihenfolge sie ihre Pegel ändern, wird entweder ein Schritt im oder gegen den Uhrzeigersinn gezählt.
              <br>
              Das Ergebnis: eine variable "position", die die Lenkbewegung in diskrete Schritte auflöst &ndash; und schließlich als serieller Wert (mit Serial.println(position * 25);) über Bluetooth verschickt wird.
            </p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>5.4 Die Empfängerseite: vJoy als Gamecontroller-Emulator</p></div>
          <div class="chapter__container-text">
            <p>Auf dem PC lauscht ein kleines Python-Skript der seriellen Verbindung. Sobald der HC-05 vom Betriebssystem erkannt und einem COM-Port zugewiesen wurde 
              (z.B. COM6), beginnt das Skript mit dem Auslesen der Werte:</p>
            <p>
              line = ser.readline().decode('utf-8').strip() 
              <br>
              lenkradWert = int(line) 
              <br>
              mapped_value = int((lenkradWert / 1023) * 32767)
            </p>
            <p>Dabei wird der gelesene Encoderwert auf den Wertebereich einer vJoy-Achse (0&ndash;32767) skaliert. Anschließend schreibt das Skript den Wert auf die virtuelle X-Achse eines vJoy-Gamecontrollers. 
              Spiele wie Forza Horizon interpretieren das Ganze dann wie ein echtes Lenkradsignal &ndash; und das ganz ohne teure Hardware oder komplexe Treiber.
              <br>
              Das Python-Skript selbst ist extrem schlank, robust und läuft im Grunde „einfach so“. Kein Schnickschnack &ndash; aber eben auch keine Probleme.
            </p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>5.5 Robustheit, Geschwindigkeit, Alltagstauglichkeit</p></div>
          <div class="chapter__container-text">
            <p>Die Verbindung ist überraschend stabil &ndash; auch wenn sie im Vergleich zu professionellen Controllern wie einem Xbox Wireless Pad beim Verbindungsaufbau etwas träge wirkt. 
              Doch: Einmal verbunden, läuft alles sauber.</p>
            <p>Da Latenzen für dieses Projekt keine kritische Rolle spielten, wurden keine weiteren Optimierungen in Richtung Echtzeitübertragung umgesetzt 
              &ndash; eine bewusste Entscheidung zugunsten von Einfachheit und Nachvollziehbarkeit.</p>
            <p>Wichtig: Das Setup ist keine Plug-and-Play-Lösung, sondern bewusst so offen gehalten, dass man daraus lernen kann. Das Ziel war nie, ein perfektes kommerzielles Produkt zu schaffen 
              &ndash; sondern ein funktionierendes, verstehbares System, das zeigt, wie man vom elektrischen Signal zur Spielsteuerung gelangt.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>5.6 Reflexion: Besser geht&rsquo;s (fast) nicht</p></div>
          <div class="chapter__container-text">
            <p>Rückblickend war die Entscheidung für Bluetooth genau richtig. Es war schnell verfügbar, einfach integrierbar und erfüllte seinen Zweck zu 100 %. 
              Die Kombination aus ESP, ADS1115, Encoder, HC-05 und Python ist schlank, logisch und stabil.</p>
            <p>Natürlich gäbe es noch Optimierungsmöglichkeiten: feinere Triggergrenzen, softwareseitige Glättung der Werte, adaptive Mapping-Funktionen 
              &ndash; aber nötig ist das alles nicht. Das System funktioniert. Punkt.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>5.7 Exkurs: Schmitt-Trigger, ADS1115, vJoy &ndash; ein kurzer Technikblick</p></div>
          <div class="chapter__container-text">
            <p>Schmitt-Trigger:
              <br>
              Ein Schmitt-Trigger ist ein Logikbaustein, der ein Signal erst dann als „geändert“ betrachtet, wenn es eine obere oder untere Schwelle überschreitet. 
              Diese Technik wird genutzt, um verrauschte oder unsaubere Signale zu stabilisieren 
              &ndash; insbesondere bei mechanischen Kontakten oder analogen Wandlern.</p>
            <p>ADS1115:
              <br>
              Der ADS1115 ist ein 16-bit-Analog-Digital-Wandler mit vier Eingängen, I²C-Schnittstelle und hoher Genauigkeit. 
              Er eignet sich ideal für Sensoranwendungen, bei denen Spannungsschwankungen präzise erkannt werden sollen 
              &ndash; z.B. bei Potentiometern, Hall-Sensoren oder eben Encoder-Signalen.</p>
            <p>vJoy:
              <br>
              vJoy ist ein virtueller Gamecontroller-Treiber für Windows. Über eine API kann man Achsen, Buttons und andere Eingabeelemente simulieren. 
              Das macht vJoy zum idealen Bindeglied zwischen Bastelprojekten und kommerziellen Spielen 
              &ndash; ohne dass man eigene Treiber entwickeln muss.</p>
          </div>
        </div>
      </section>

      <section class="chapter" id="chapter-6">
        <div class="chapter__headline"><p>6. Reflexion & Weiterdenken</p></div>
        <div class="chapter__subhead">
          <p>Manches funktioniert direkt. Manches nicht. Entscheidend ist, was man daraus macht.</p>
          <p>Was bleibt hängen, wenn das Projekt abgeschlossen ist? Diese Frage stellt sich spätestens dann, wenn der letzte Druck abgeschlossen, 
            der letzte Code geschrieben und die letzte Schraube angezogen wurde. In diesem Kapitel geht es nicht darum, den Simulator an käufliche Fertigprodukte zu messen. 
            Es geht um Eigenleistung, um Ideen, und darum, was sich daraus entwickelt &ndash; technisch wie gedanklich.</p>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>6.1 Lieblingsbaustellen und elegante Lösungen</p></div>
          <div class="chapter__container-text">
            <p>Manche Bauteile sind nicht nur funktional, sondern machen einfach Freude &ndash; sei es beim Konstruieren, beim Zusammenbauen oder im Ergebnis. 
              Zwei Elemente haben sich dabei besonders hervorgetan: Zum einen die Spiral-Torsionsfedern, die nicht nur ungewöhnlich gewählt, sondern auch überraschend effizient waren. 
              Sie verleihen der Lenkung eine gleichmäßige Rückstellkraft, ohne dabei viel Platz zu benötigen 
              &ndash; und vor allem: Sie funktionieren besser, als zunächst erwartet.</p>
            <p>Zum anderen ist es die Encodertechnik, die, auch wenn nicht in Perfektion umgesetzt, das Herzstück der Signalerfassung bildet. 
              In Kombination mit den eingesetzten Kugellagern ergibt sich eine sehr elegante mechanische Lösung. 
              Die Lager laufen nahezu reibungslos, verteilen die Kräfte gleichmäßig und tragen wesentlich dazu bei, dass sich das Lenksystem weich und direkt anfühlt. 
              Natürlich gäbe es an anderer Stelle Optimierungspotenzial &ndash; etwa bei der Gestaltung der Stromabnehmer oder der Effizienz der Encoderaufnahme. 
              Aber als Gesamtkonstruktion überzeugt der Aufbau durch ein durchdachtes Zusammenspiel aller Teile.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>6.2 Pläne, die nicht realisiert wurden &ndash; und warum das okay ist</p></div>
          <div class="chapter__container-text">
            <p>Nicht jeder Gedanke, der während des Bauprozesses entsteht, muss auch zu einem vollendeten Ergebnis führen. Ursprünglich war angedacht, den Simulator modularer aufzubauen 
              &ndash; mit Adaptern für Tische oder ergänzenden Halterungen. Auch hier zeigte sich aber, dass sich der Nutzen nicht in Relation zum Aufwand setzte. 
              Der Fokus verlagerte sich stattdessen auf die zentrale technische Machbarkeit.</p>
            <p>Wirklich hartnäckig zeigten sich die Stromabnehmer &ndash; und obwohl die finale Lösung funktional war, bleibt sie ein kleiner Kritikpunkt. Trotzdem gilt: Das System funktioniert. 
              Und das war von Anfang an die zentrale Überzeugung &ndash; auch wenn nicht alles auf Anhieb gelang. Das Wissen, dass sich das Vorhaben grundsätzlich umsetzen lässt, 
              war über den gesamten Zeitraum präsent &ndash; ein wertvoller Motor für das Durchhalten</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>6.3 Was ich gelernt habe</p></div>
          <div class="chapter__container-text">
            <p>Das Projekt war vor allem eines: eine technische Lernreise. Ich konnte mein Wissen in verschiedenen Bereichen deutlich erweitern 
              &ndash; angefangen beim CAD-Design und 3D-Druck, wo ich lernte, mechanische Komponenten funktional zu konstruieren, Toleranzen gezielt einzuplanen und Vorspannung kontrolliert einzubringen. 
              Die Verbindung von Software (Fusion 360) und Hardware (Bambu Studio, Drucker) eröffnete mir ein neues Verständnis für präzise Bauteilgestaltung.</p>
            <p>Auch mechanisch hat sich mein Blick geschärft: Kraftverläufe, Lagerungen, Federwirkung &ndash; all das wurde vom bloßen Konzept zur spürbaren Realität. 
              Gerade das Zusammenspiel aus Federn und Kugellagern erforderte ein gewisses Feingefühl, das ich mir erst im Laufe der Arbeit aneignen musste.</p>
            <p>Im Bereich der Programmierung betrat ich fast vollständig neues Terrain. Während ich zuvor schon mit Arduino gearbeitet hatte, war die Welt von Python, 
              serieller Kommunikation per Bluetooth und der Einbindung in virtuelle Eingabegeräte (vJoy) neu für mich &ndash; aber genau deshalb auch besonders spannend. 
              Das Zusammenspiel aus Mikrocontroller, Signalübertragung und PC-Steuerung funktionierte am Ende nicht nur zuverlässig, 
              sondern vermittelte mir ein ganz neues Verständnis davon, wie Soft- und Hardware ineinandergreifen.</p>
            <p>Hilfreich war dabei vor allem die Mischung aus systematischem Vorgehen, Ausprobieren und stetigem Verstehen. 
              Selbst das Arbeiten mit der Kommandozeile, das mir anfangs eher fremd erschien, wurde mit der Zeit zur Selbstverständlichkeit.</p>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>6.4 Ideen, die bleiben &ndash; auch wenn das Projekt abgeschlossen ist</p></div>
          <div class="chapter__container-text">
            <p>Der Simulator wird aktuell nicht aktiv verwendet. Zwar ist er funktional, allerdings wären gezielte Verbesserungen an der Encodertechnik nötig, um ihn dauerhaft in Spielen wie Forza Horizon einzusetzen. 
              Doch auch wenn das Projekt nicht produktiv weiterverwendet wird &ndash; die Gedanken, die es angestoßen hat, bleiben.</p>
            <p>Einer dieser Gedanken ist die Idee, den Controller zu einem echten Fernsteuergerät für ein selbstgebautes RC-Auto weiterzuentwickeln. 
              Ein Auto, das nicht durch Spielzeugtechnik, sondern durch durchdachtes Fahrwerksdesign, Lenktechnik und Kommunikationslogik überzeugt. Ohne Motor vielleicht 
              &ndash; aber mit dem vollen Fokus auf die Aspekte, die mich auch am echten Auto faszinieren: Fahrwerk, Kraftverteilung, Lenkgefühl.</p>
          </div>
        </div>
      </section>

      <section class="chapter" id="chapter-7">
        <div class="chapter__headline"><p>7. Künstliche Intelligenz: Mitdenken auf Abruf</p></div>
        <div class="chapter__subhead">
          <p>Komplexe Projekte wie dieser Simulator lassen sich selten völlig im Alleingang stemmen 
            &ndash; zumindest nicht dann, wenn man gleichzeitig neue Bereiche erkunden, Fehler verstehen und gleichzeitig an der Umsetzung feilen will. 
            Umso wertvoller war es, während der Entwicklung auf ChatGPT von OpenAI zurückgreifen zu können. 
            Nicht als Lösungslieferant oder gar automatischer Codegenerator, sondern als technischer Sparringspartner.</p>
          <p>Die Rolle, die ChatGPT dabei spielte, ähnelte am ehesten einem kompetenten Mitdenker: ein Gesprächspartner, der immer dann zur Verfügung stand, 
            wenn ein kleiner Impuls, ein Denkanstoß oder eine zweite Sichtweise nötig war &ndash; sei es beim Aufsetzen des Python-Skripts, bei der Auswertung der Sensordaten oder beim Debugging der Bluetooth-Verbindung. 
            Besonders hilfreich war das bei Themen, in die ich mich erst neu einarbeiten musste: 
            die Anbindung über vJoy, der Umgang mit cmd oder das korrekte Timing bei der Signalverarbeitung.</p>
          <p>Natürlich verlief nicht jede Hilfestellung reibungslos. Manchmal waren mehrere Anläufe nötig, bis der Vorschlag zu meinem Aufbau passte 
            &ndash; und oft waren es gerade die Rückfragen und Nachbesserungen, durch die ich mein eigenes Verständnis vertiefen konnte. Das macht die Zusammenarbeit umso wertvoller: 
            nicht als Ersatz für eigenes Denken, sondern als Katalysator für genau dieses Denken.</p>
          <p>ChatGPT hat in diesem Projekt keine Entwürfe gezeichnet, keine Bauteile ausgedruckt und auch keinen einzigen Draht gelötet. 
            Die Idee, die Umsetzung und die konstruktiven Entscheidungen lagen vollständig bei mir. Aber die Möglichkeit, technische Fragestellungen direkt mit einer KI durchzuspielen, hat den Entwurfsprozess effizienter, präziser 
            &ndash; und manchmal auch einfach entspannter gemacht. Gerade bei umfangreichen Eigenprojekten ist das ein Vorteil, der kaum zu überschätzen ist.</p>
          <p>Mitdenken auf Abruf &ndash; das beschreibt ziemlich genau, wie sich diese Art der Zusammenarbeit anfühlt. 
            Und wahrscheinlich wird sie bei kommenden Projekten nicht weniger wichtig sein.</p>
        </div>
      </section>
      
      <section class="chapter" id="chapter-8">
        <div class="chapter__headline"><p>8. Downloads</p></div>
        <div class="chapter__subhead">
          <p>Hier findest du alle wichtigen Dateien rund um das Projekt: vom Quellcode bis hin zum 3D-Modell. Diese Sammlung dient nicht als Bauanleitung 
            &ndash; sondern als offene Quelle zum Verstehen, Ausprobieren oder Weiterentwickeln.</p>
          <p>Wer technisch interessiert ist oder selbst mit CAD, Mikrocontrollern oder Python experimentieren möchte, findet hier einen guten Einstiegspunkt.</p>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>7.1 Programme & Code</p></div>
          <div class="chapter__container-downloads">
            <div class="chapter__container-text">
              <p>Arduino-Sketch (ESP8266)
                <br>
                Enthält das Programm für den Mikrocontroller: Auslesen der Sensorwerte über den ADS1115 und Senden per Bluetooth (HC-05). Der Code ist kommentiert und lässt sich bei Bedarf leicht anpassen.
              </p>
            </div>
            <div class="chapter__cta-links">
              <a class="button button--border" href="downloads/rs-arduino/rs-arduino.ino" download>Download</a>
            </div>
          </div>
          <div class="chapter__container-downloads">
            <div class="chapter__container-text">
              <p>Python-Skript für Windows
                <br>
                Läuft auf dem PC und empfängt die seriellen Bluetooth-Daten des ESP8266. Anschließend werden die Signale mithilfe von vJoy in Game-Eingaben übersetzt. 
                Vorausgesetzt werden PySerial, vJoy und ein Basisverständnis für Python-Skripte.
              </p>
            </div>
            <div class="chapter__cta-links">
              <a class="button button--border" href="downloads/bt_to_vjoy.py" download>Download</a>
            </div>
          </div>
          <div class="chapter__container-downloads">
            <div class="chapter__container-text">
              <p>CMD-Autostart-Dateien (Batch)
                <br>
                Ergänzende .bat-Dateien zur einfachen Ausführung des Python-Skripts &ndash; optional mit Autostart-Verhalten. Praktisch für Testzwecke oder Alltagsbetrieb.
              </p>
            </div>
            <div class="chapter__cta-links">
              <a class="button button--border" href="downloads/start_wheel.bat" download>Download</a>
            </div>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>7.2 CAD & Mechanik</p></div>
          <div class="chapter__container-downloads">
            <div class="chapter__container-text">
              <p>Fusion 360 Gesamtmodell (f3d-Datei)
                <br>
                Eine vollständige 3D-Datei des aufgebauten Simulators &ndash; zur Ansicht, Analyse oder Weiterverarbeitung in anderen CAD-Programmen. 
                Ideal, um das Zusammenspiel von Bauteilen zu verstehen. Nicht als fertiger Bauplan gedacht.
              </p>
            </div>
            <div class="chapter__cta-links">
              <a class="button button--border" href="downloads/wheel_3d.f3d" download>Download</a>
            </div>
          </div>
          <div class="chapter__container-downloads">
            <div class="chapter__container-text">
              <p>Dreitafelprojektion (PDF)
                <br>
                Zeigt den Simulator klassisch aus Vorder-, Seiten- und Draufsicht. 
                Nützlich zur Orientierung im Aufbau oder zur Analyse der Geometrie. Erstellt aus dem Fusion-Export.
              </p>
            </div>
            <div class="chapter__cta-links">
              <a class="button button--border" href="downloads/wheel_drawing.pdf" download>Download</a>
            </div>
          </div>
        </div>
        <div class="chapter__container">
          <div class="chapter__container-headline"><p>7.3 Dokumentation</p></div>
          <div class="chapter__container-downloads">
            <div class="chapter__container-text">
              <p>Projektbericht (PDF)
                <br>
                Die ausführliche schriftliche Dokumentation &ndash; mit Reflexion, Hintergrund und vielen technischen Details. 
                Diese Website basiert auf dem Bericht, erweitert ihn aber um neue Gedanken und Visualisierungen.
              </p>
            </div>
            <div class="chapter__cta-links">
              <a class="button button--border" href="downloads/wheel_report.pdf" download>Download</a>
            </div>
          </div>
        </div>
      </section>
    </main>

    <footer class="footer">
      <div class="footer__layout">
        <div class="footer__intro">
          <div class="footer__intro-quote">
            <p>"Forschung betreibe ich dann, wenn ich nicht weiß, was ich tue.”</p>
          </div>
          <div class="footer__intro-author"><p>Wernher von Braun</p></div>
        </div>
        <div class="footer__name"><p>Niklas Schwabauer</p></div>
        <div class="footer__content">
          <div class="footer__section">
            <div class="footer__headline"><p>Links</p></div>
            <ul class="footer__menu">
              <li class="footer__menu-link"><a href="index.html">Homepage</a></li>
              <li class="footer__menu-link"><a href="projects.html">Projekte</a></li>
              <li class="footer__menu-link"><a href="personal.html">Profil</a></li>
              <li class="footer__menu-link"><a href="blog.html">Blog</a></li>
            </ul>
          </div>
          <div class="footer__section">
            <div class="footer__headline"><p>Socials</p></div>
            <ul class="footer__menu">
              <li class="footer__menu-link"><a href="https://github.com/niklasschwabauer" target="_blank" rel="noopener noreferrer">GitHub</a></li>
              <li class="footer__menu-link"><a href="https://www.instagram.com/0815_niklas/" target="_blank" rel="noopener noreferrer">Instagram</a></li>
              <li class="footer__menu-link"><a href="https://x.com/0815niklas_" target="_blank" rel="noopener noreferrer">X</a></li>
              <li class="footer__menu-link"><a href="https://www.chess.com/member/0815Niklas" target="_blank" rel="noopener noreferrer">Chess.com</a></li>
              <li class="footer__menu-link"><a href="https://www.youtube.com/@0815niklas" target="_blank" rel="noopener noreferrer">Youtube</a></li>
            </ul>
          </div>
          <div class="footer__section footer__wide">
            <div class="footer__headline"><p>Newsletter</p></div>
            <ul class="footer__menu">
              <li class="footer__menu-link"><a href="#">Jetzt anmelden!</a></li>
            </ul>
          </div>
          <div class="footer__section">
            <div class="footer__headline"><p>Kontakt</p></div>
            <ul class="footer__menu">
              <li class="footer__menu-link"><a href="mailto:niklasschwabauer@gmail.com">Email</a></li>
            </ul>
          </div>
        </div>
      </div>
    </footer>
  </body>
</html>
